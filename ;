import math
import mmh3
import numpy as np
import struct
import time

class Bifilter:

  def __init__(self, includes=set(), excludes=set()):
    assert not includes & excludes, 'includes and excludes cannot intersect'
    self.layers = []
    while len(includes) + len(excludes) > 0:
      s = len(self.layers)
      n = len(includes) + len(excludes)
      k = max(32, int(2 - 0.5 * n / math.log(1 - 1.0 / 2**0.5)))

      # Record which buckets get mapped include and exclude elements
      start_time = time.time()
      include_buckets = np.zeros(k, np.bool)
      exclude_buckets = np.zeros(k, np.bool)
      for el in includes:
        include_buckets[self.__bucket(el, s, k)] = True
      for el in excludes:
        exclude_buckets[self.__bucket(el, s, k)] = True

      # Compute this layer and the recursive set
      next_includes = []
      next_excludes = []
      layer = np.zeros(k, np.int32)
      for el in includes:
        i = self.__bucket(el, s, k)
        if exclude_buckets[i]:
          layer[i] = 2  # Bucket is ambiguous
          next_includes.append(el)
        else:
          layer[i] = 0  # Element is umabiguously included
      for el in excludes:
        i = self.__bucket(el, s, k)
        if include_buckets[i]:
          assert layer[i] == 2 # Bucket should be marked ambiguous
          next_excludes.append(el)
        else:
          layer[i] = 1  # Element is umabiguously excluded

      # Recurse until nothing is ambiguous.
      includes = next_includes
      excludes = next_excludes
      self.layers.append(layer)

    
  def __contains__(self, element):
    for i, layer in enumerate(self.layers):
      state = layer[self.__bucket(element, i, len(layer))]
      assert state in (0, 1, 2)
      if state == 0:
        return True
      elif state == 1:
        return False
    raise LookupError('Invalid state. Final layer should be unambiguous')

  def partition(self, elements):
    includes, excludes = [], []
      remaining = elements
    for i, layer:
      for element in remaining:

  @staticmethod
  def __bucket(element, level, range): 
    return mmh3.hash(struct.pack('L', element), level) % range

  def dumps(self):
    branch_bits = []
    leaves_bits = []
    for layer in self.layers:
      for state in layer:
        if state == 2:
          branch_bits.append(0)
        else:
          branch_bits.append(1)
          leaves_bits.append(state)
    return np.packbits(branch_bits + leaves_bits)

  @staticmethod
  def loads(encoding):
    pass


def test():
  import random, time
  n = 1000
  candidates = range(n)
  random.shuffle(candidates)
  includes = candidates[:n/2]
  excludes = candidates[n/2:]

  start = time.time()
  bifilter = Bifilter(set(includes), set(excludes))
  for el in includes:
    assert el in bifilter
  for el in excludes:
    assert el not in bifilter
  total_time = time.time() - start
  print "Success! Took: %s seconds" % total_time
  print "Encoding size:", len(bifilter.dumps())

  for i, layer in enumerate(bifilter.layers):
    print "layer %d, type 0: %d" % (i, sum(1 for x in layer if x == 0))
    print "layer %d, type 1: %d" % (i, sum(1 for x in layer if x == 1))
    print "layer %d, type 2: %d" % (i, sum(1 for x in layer if x == 2))


if __name__ == '__main__':
  test()
